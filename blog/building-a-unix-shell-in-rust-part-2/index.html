<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
Building a Unix-shell in Rust - Part 2 &middot; T.J. Telan
</title>

  <!-- CSS -->
  <link rel="stylesheet" href="https://tjtelan.com/print.css" media="print">
  <link rel="stylesheet" href="https://tjtelan.com/tj.css">
  <!--<link rel="stylesheet" href="https://tjtelan.com/newsletter.css">-->
  <link rel="stylesheet" href="https://tjtelan.com/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  
  
  <link rel="alternate" type="application/atom+xml" title="Atom" href="https://tjtelan.com/atom.xml">
  
  
  
  <!-- Facebook open graph tags-->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://tjtelan.com/blog/building-a-unix-shell-in-rust-part-2/" />
   
  <meta property="og:title" content="Building a Unix-shell in Rust - Part 2" />
  
  
  <meta property="og:description" content="Beginning to interactive shell with Rust" />
  
  <!-- Twitter card tags -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:url" content="https://tjtelan.com/blog/building-a-unix-shell-in-rust-part-2/" />
   
  <meta name="twitter:title" content="Building a Unix-shell in Rust - Part 2" />
  
  
  <meta name="twitter:description" content="Beginning to interactive shell with Rust" />
  
  <meta name="twitter:creator" content="@ThatTJTelan" />
  <meta name="twitter:site" content="@ThatTJTelan" />

  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-M280GK01DY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M280GK01DY');
</script>


<!-- Plausible Analytics -->
<script defer data-domain="tjtelan.com" src="https://analytics.analogorithm.net/js/script.js"></script>

</head>

<body class=" ">
  
  <div  id="sidebar" class="sidebar">
    <div class="container sidebar-sticky">
      <div class="sidebar-about">
        
        <a href="https://tjtelan.com">
          <h1>T.J. Telan</h1>
        </a>
        
        <p class="lede">Practical DevOps &amp; Developer Experience</p>
        
        
      </div>

      <ul class="sidebar-nav">
        
          
            
            <li class="sidebar-nav-item">
              <a href="/now/">Now</a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="/about/">About</a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="https://github.com/tjtelan">Github<img src="/nav-icons/github.svg" alt="Github"></a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="https://dev.to/tjtelan">Dev.to<img src="/nav-icons/dev-dot-to.svg" alt="Dev.to"></a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="https://medium.com/@tjtelan">Medium<img src="/nav-icons/medium.svg" alt="Medium"></a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="https://twitter.com/ThatTJTelan">Twitter<img src="/nav-icons/twitter.svg" alt="Twitter"></a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="https://www.twitch.tv/tjtelan">Twitch<img src="/nav-icons/twitch.svg" alt="Twitch"></a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="https://www.youtube.com/channel/UCiwV2NFMF26A5nfakQbuZ-g">YouTube<img src="/nav-icons/youtube.svg" alt="YouTube"></a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="/atom.xml">RSS<img src="/nav-icons/rss.svg" alt="RSS"></a>
            </li>
            
          
        
      </ul>
    </div>
  </div>
  

  <div class="content container">
    
<div class="post">
    <h1 class="post-title">Building a Unix-shell in Rust - Part 2</h1>
    
    <span class="post-meta">
        8 min read
        &nbsp;&bull;&nbsp;
        2017-11-26
        
          &nbsp;&bull;
          
          &nbsp;
          <a  href="https://tjtelan.com/categories/how-to/">
              how-to
            </a>
          
        
        
          &nbsp;&bull;
          
          &nbsp;
          <a  href="https://tjtelan.com/tags/rust/">
              #rust
            </a>
          
        
      </span>

    <p>This is the 2nd part of a series where I document writing a command shell in Rust. In the <a href="https://tjtelan.com/blog/building-a-unix-shell-in-rust-part-1/">previous post</a> I reviewed what a shell is, and broke that down into stages I can use to organize my code.</p>
<h3 id="getting-user-input">Getting user input<a class="zola-anchor" href="#getting-user-input" aria-label="Anchor link for: getting-user-input">ðŸ”—</a></h3>
<p>First thing we need to do is create a project. Letâ€™s use Cargo to create this for us.</p>
<pre data-lang="sh" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo new --bin rust-shell
</span></code></pre>
<p>For now, I'm going to assume we are only running interactively. So I'm just going to get a simple loop set up that asks for an input, and echoes it back to me.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">use </span><span>std::io;
</span><span>
</span><span style="color:#569cd6;">fn </span><span>main() {
</span><span>  </span><span style="color:#569cd6;">loop </span><span>{
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> command = String::new();
</span><span>    io::stdin().read_line(</span><span style="color:#569cd6;">&amp;mut</span><span> command)
</span><span>      .expect(</span><span style="color:#d69d85;">&quot;Failed to read in command&quot;</span><span>);
</span><span>    println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{0}</span><span style="color:#d69d85;">&quot;</span><span>, command);
</span><span>  }
</span><span>}
</span></code></pre>
<p>Iâ€™m using std::io to read input into the mutable command variable binding, then I println() to echo my input back to the screen.</p>
<p>Then we build:</p>
<pre data-lang="sh" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo build
</span><span>   Compiling rust-shell v0.1.0 (file:///Users/telant/src/rust-shell)
</span><span>    Finished dev </span><span style="color:#569cd6;">[</span><span>unoptimized + debuginfo</span><span style="color:#569cd6;">]</span><span> target(s) in 0.25 secs
</span></code></pre>
<p>No errors.</p>
<p>And testing it out:</p>
<pre data-lang="sh" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo run
</span><span>    Finished dev </span><span style="color:#569cd6;">[</span><span>unoptimized + debuginfo</span><span style="color:#569cd6;">]</span><span> target(s) in 0.0 secs
</span><span>     Running `target/debug/rust-shell`
</span><span>123
</span><span>123
</span><span>
</span><span>test
</span><span>test
</span></code></pre>
<p>Great. Looks like that was easy.</p>
<p>What we see here is me trying 2 commands: <code>123</code> and <code>test</code>. We see the command printed right back. (Printing a short prompt might make that more obviousâ€¦ ) </p>
<h3 id="parsing-the-input-into-tokens">Parsing the input into tokens<a class="zola-anchor" href="#parsing-the-input-into-tokens" aria-label="Anchor link for: parsing-the-input-into-tokens">ðŸ”—</a></h3>
<p>Next step is to break the user input from a single continuous string into smaller pieces that we can evaluate. </p>
<p>I am just going to tokenize the string using spaces as delimiters (because it is easy. It is, however, not always accurate, but, Dear Reader, I already know this is not the final way I am going to implement tokens. Splitting on spaces is too greedy of an approach. Quoted arguments are usually evaluated to be a single argument, including spaces, for uses that include passing entire raw strings to other programs. Let's not get perfection distract us. I'll stay focused on getting something that works...)</p>
<p>I actually ran into a little bit of trouble getting this working on a single line, with the original variable because of the type checker.</p>
<p>This did not work:</p>
<pre data-lang="sh" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo build
</span><span>   Compiling rust-shell v0.1.0 (file:///Users/telant/src/rust-shell)
</span><span>error[E0282]: unable to infer enough type information about `B`
</span><span>  --&gt; src/main.rs:11:41
</span><span>   </span><span style="color:#569cd6;">|
</span><span>11 </span><span style="color:#569cd6;">|     </span><span>println!(</span><span style="color:#d69d85;">&quot;{:?}&quot;</span><span>, command.split(</span><span style="color:#d69d85;">&#39; &#39;</span><span>).collect());
</span><span>   |                                         ^^^^^^^ cannot infer type for `B`
</span><span>   |
</span><span>   = note: type annotations or generic parameter binding required
</span></code></pre>
<p>Iâ€™m lazy, and I didnâ€™t look into how to explicitly reference the type.</p>
<p>This did work. </p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">let</span><span> command_split : Vec&lt;</span><span style="color:#569cd6;">&amp;str</span><span>&gt; = command.split(</span><span style="color:#d69d85;">&#39; &#39;</span><span>).collect();
</span><span>println!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span>, command_split);
</span></code></pre>
<p>This is the relevant output</p>
<pre data-lang="sh" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-sh "><code class="language-sh" data-lang="sh"><span>test test test
</span><span>[</span><span style="color:#d69d85;">&quot;test&quot;</span><span>, </span><span style="color:#d69d85;">&quot;test&quot;</span><span>, </span><span style="color:#d69d85;">&quot;test\n&quot;</span><span>]
</span></code></pre>
<pre data-lang="sh" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-sh "><code class="language-sh" data-lang="sh"><span>blah blah </span><span style="color:#d69d85;">&quot;string in quotes&quot;
</span><span>[</span><span style="color:#d69d85;">&quot;blah&quot;</span><span>, </span><span style="color:#d69d85;">&quot;blah&quot;</span><span>, </span><span style="color:#d69d85;">&quot;</span><span style="color:#e3bbab;">\&quot;</span><span style="color:#d69d85;">string&quot;</span><span>, </span><span style="color:#d69d85;">&quot;in&quot;</span><span>, </span><span style="color:#d69d85;">&quot;quotes</span><span style="color:#e3bbab;">\&quot;</span><span style="color:#d69d85;">\n&quot;</span><span>]
</span></code></pre>
<p>Iâ€™m going to have to learn how type inference works in Rust sooner or later, but Iâ€™m not going to deal with it now. String types in Rust are kind of confusing coming from Python where I donâ€™t have to deal with types very often.</p>
<p>(This is a warning from the future. You should lightly understand the idiomatic difference between String and &amp;str. You find this out the hard way when you get to refactoringâ€¦ see you in the future)</p>
<p>Iâ€™m going to use this moment to make the interface a more obvious when the we are ready to take user input by printing a prompt character.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">use </span><span>std::io::{self,Write};
</span><span>
</span><span style="color:#569cd6;">fn </span><span>main() {
</span><span>  </span><span style="color:#569cd6;">let</span><span> prompt_char = </span><span style="color:#d69d85;">&quot;%&quot;</span><span>;
</span><span>  </span><span style="color:#569cd6;">loop </span><span>{
</span><span>    print!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{0} </span><span style="color:#d69d85;">&quot;</span><span>, prompt_char);
</span><span>    io::stdout().flush().unwrap();
</span><span>
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> command = String::new();
</span><span>    io::stdin().read_line(</span><span style="color:#569cd6;">&amp;mut</span><span> command)
</span><span>      .expect(</span><span style="color:#d69d85;">&quot;Failed to read in command&quot;</span><span>);
</span><span>    println!(</span><span style="color:#d69d85;">&quot;DEBUG: </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span>, command);
</span><span>
</span><span>    </span><span style="color:#569cd6;">let</span><span> command_split : Vec&lt;</span><span style="color:#569cd6;">&amp;str</span><span>&gt; = command.split(</span><span style="color:#d69d85;">&#39; &#39;</span><span>).collect();
</span><span>    println!(</span><span style="color:#d69d85;">&quot;DEBUG: </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span>, command_split);
</span><span>  }
</span><span>}
</span></code></pre>
<p>I added <code>DEBUG:</code> to our debug statements. Also I had to include a new <code>use</code>, use the <code>print!</code> macro, and flush the buffer so it would print to the screen immediately.</p>
<p>I got this pattern from the Rust docs for <a rel="noopener nofollow" target="_blank" href="https://doc.rust-lang.org/1.4.0/std/macro.print!.html">print!</a></p>
<pre data-lang="sh" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-sh "><code class="language-sh" data-lang="sh"><span>$ cargo run
</span><span>    Finished dev </span><span style="color:#569cd6;">[</span><span>unoptimized + debuginfo</span><span style="color:#569cd6;">]</span><span> target(s) in 0.0 secs
</span><span>     Running `target/debug/rust-shell`
</span><span>% Feeling a little more shell-like now
</span><span>DEBUG: </span><span style="color:#d69d85;">&quot;Feeling a little more shell-like now\n&quot;
</span><span>DEBUG: </span><span style="color:#569cd6;">[</span><span style="color:#d69d85;">&quot;Feeling&quot;</span><span>, </span><span style="color:#d69d85;">&quot;a&quot;</span><span>, </span><span style="color:#d69d85;">&quot;little&quot;</span><span>, </span><span style="color:#d69d85;">&quot;more&quot;</span><span>, </span><span style="color:#d69d85;">&quot;shell-like&quot;</span><span>, </span><span style="color:#d69d85;">&quot;now\n&quot;</span><span style="color:#569cd6;">]
</span><span>%
</span></code></pre>
<h3 id="classifying-parsed-input">Classifying parsed input<a class="zola-anchor" href="#classifying-parsed-input" aria-label="Anchor link for: classifying-parsed-input">ðŸ”—</a></h3>
<p>Last thing Iâ€™m going to do is identify the keyword from the arguments, then Iâ€™ll do a little refactoring to help organize the new complexity. (I expect to do a little fighting with the borrow checker at this point.)</p>
<p>Getting the keyword is easy. I just need to pick off the first element of our tokenized command.</p>
<p>The arguments is a vector slice of everything but the first element of the command. Can I slice a vector as easily as slicing lists in Python? Yes.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">use </span><span>std::io::{self,Write};
</span><span>
</span><span style="color:#569cd6;">fn </span><span>main() {
</span><span>  </span><span style="color:#569cd6;">let</span><span> prompt_char = </span><span style="color:#d69d85;">&quot;%&quot;</span><span>;
</span><span>  </span><span style="color:#569cd6;">loop </span><span>{
</span><span>    print!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{0} </span><span style="color:#d69d85;">&quot;</span><span>, prompt_char);
</span><span>    io::stdout().flush().unwrap();
</span><span>
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> command = String::new();
</span><span>    io::stdin().read_line(</span><span style="color:#569cd6;">&amp;mut</span><span> command)
</span><span>      .expect(</span><span style="color:#d69d85;">&quot;Failed to read in command&quot;</span><span>);
</span><span>    println!(</span><span style="color:#d69d85;">&quot;DEBUG: Raw input: </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span>, command);
</span><span>
</span><span>    </span><span style="color:#569cd6;">let</span><span> command_split : Vec&lt;</span><span style="color:#569cd6;">&amp;str</span><span>&gt; = command.split(</span><span style="color:#d69d85;">&#39; &#39;</span><span>).collect();
</span><span>    println!(</span><span style="color:#d69d85;">&quot;DEBUG: Split input: </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span>, command_split);
</span><span>
</span><span>    </span><span style="color:#569cd6;">let</span><span> keyword = command_split[</span><span style="color:#b5cea8;">0</span><span>];
</span><span>    </span><span style="color:#569cd6;">let</span><span> arguments = </span><span style="color:#569cd6;">&amp;</span><span>command_split[</span><span style="color:#b5cea8;">1</span><span style="color:#569cd6;">..</span><span>];
</span><span>
</span><span>    println!(</span><span style="color:#d69d85;">&quot;DEBUG: Keyword: </span><span style="color:#b4cea8;">{0}</span><span style="color:#d69d85;">&quot;</span><span>, keyword);
</span><span>    println!(</span><span style="color:#d69d85;">&quot;DEBUG: Number of arguments: </span><span style="color:#b4cea8;">{0:?}</span><span style="color:#e3bbab;">\n</span><span style="color:#d69d85;">DEBUG: Arguments: </span><span style="color:#b4cea8;">{1:?}</span><span style="color:#d69d85;">&quot;</span><span>, arguments.len(), arguments);
</span><span>  }
</span><span>}
</span></code></pre>
<p>I have to call the slice by reference using <code>&amp;</code> with the vector, and I specified the range I wanted to slice with the element I want to start from and <code>..</code> without an ending element. Rust figures out the bounds in this case.</p>
<h3 id="time-to-refactor">Time to refactor!<a class="zola-anchor" href="#time-to-refactor" aria-label="Anchor link for: time-to-refactor">ðŸ”—</a></h3>
<p>Iâ€™m going to make the main loop look a little more functional (inside the loop).</p>
<p>Printing the prompt? Easy. Function call.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">fn </span><span>print_prompt() {
</span><span>  </span><span style="color:#569cd6;">let</span><span> prompt_char = </span><span style="color:#d69d85;">&quot;%&quot;</span><span>;
</span><span>
</span><span>  print!(</span><span style="color:#d69d85;">&quot;</span><span style="color:#b4cea8;">{0} </span><span style="color:#d69d85;">&quot;</span><span>, prompt_char);
</span><span>  io::stdout().flush().unwrap();
</span><span>}
</span></code></pre>
<p>Reading the command from user input? I had to look up how to return variables. The style is to use an implicit return, and no semicolon. You can use <code>return</code>, but it isn't very idiomatic. </p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">fn </span><span>read_command() -&gt; String {
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> command = String::new();
</span><span>    io::stdin().read_line(</span><span style="color:#569cd6;">&amp;mut</span><span> command)
</span><span>      .expect(</span><span style="color:#d69d85;">&quot;Failed to read in command&quot;</span><span>);
</span><span>    println!(</span><span style="color:#d69d85;">&quot;DEBUG: Raw input: </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span>, command);
</span><span>
</span><span>    command
</span><span>}
</span></code></pre>
<p>Tokenizing the command? Gonna get a little more complicated. Iâ€™m going to set up a struct to represent the command so I can keep the tokenized command together in a single object.</p>
<hr />
<h3 id="optional-first-fight-with-borrow-checker">Optional : First fight with borrow checker<a class="zola-anchor" href="#optional-first-fight-with-borrow-checker" aria-label="Anchor link for: optional-first-fight-with-borrow-checker">ðŸ”—</a></h3>
<p>I almost lost the motivation to continue the documenting my thought process because of this obstacle. This section can be skipped if you are looking to follow my happy path, and don't want to follow my confusion. </p>
<p>(This is what I wrote first, when I was actually having a fight with the borrow checkerâ€¦)</p>
<p>I have to learn a little bit about <a rel="noopener nofollow" target="_blank" href="https://doc.rust-lang.org/book/lifetimes.html">lifetimes</a> in order to get this to compile. This makes some sense, since the struct will need to own the slice data, and in the original code, we were just borrowing the slice.</p>
<p>Iâ€™m finding it confusing thinking about what I need to do in order to make the tokenizing function use the Command struct. If I can copy the args to the struct, and give ownership of the string to the struct, then I assume this will compile?</p>
<p>What type is the copied slice, and how do I specify that in the struct? How do I use the lifetime in code to find my use case? I donâ€™t even know what other questions to ask next.</p>
<p>Rather than try to figure out how to compile, and get the struct working with tokenizing the command, Iâ€™ll try to play around in main() and try instantiating my struct.</p>
<p>What I need to be able to do is copy the data in the vector. I tried for a while trying to pass ownership of a slice, but I ended up finding a way to take the first element out of the vector, and having the rest be the arguments be what is left. I feel a little over my head at this point, and Iâ€™m going to spend some time reading the docs.</p>
<p>This is what the struct looked like.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">/// Bad.
</span><span style="color:#569cd6;">struct </span><span>Command &lt;&#39;a&gt; {
</span><span>   keyword : String,
</span><span>   arguments : </span><span style="color:#569cd6;">&amp;&#39;a</span><span> [</span><span style="color:#569cd6;">&amp;&#39;a str</span><span>],
</span><span> }
</span></code></pre>
<p>The reason I went with this approach was I thought I could pass the ownership of the heap from when I split the command by whitespace. This was really not a good approach, and I wasted quite a lot of time fighting with the borrow checker.</p>
<hr />
<h3 id="back-to-the-show">Back to the show<a class="zola-anchor" href="#back-to-the-show" aria-label="Anchor link for: back-to-the-show">ðŸ”—</a></h3>
<p>I ended up changing the way I split the original command string so I would have a Vec<String> rather than Vec&lt;&amp;str&gt;. Because String is owned and &amp;str is borrowed, and the Command struct needs to own its data. </p>
<p>I think I have a much more straightforward function.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">struct </span><span>Command {
</span><span>  keyword : String,
</span><span>  args : Vec&lt;String&gt;,
</span><span>}
</span><span>
</span><span style="color:#569cd6;">fn </span><span>tokenize_command(c : String) -&gt; Command {
</span><span>  </span><span style="color:#569cd6;">let mut</span><span> command_split : Vec&lt;String&gt; = c.split_whitespace().map(|s| s.to_string()).collect();
</span><span>  println!(</span><span style="color:#d69d85;">&quot;DEBUG: Split input: </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span>, command_split);
</span><span>
</span><span>  </span><span style="color:#569cd6;">let</span><span> command = Command {
</span><span>    keyword : command_split.remove(</span><span style="color:#b5cea8;">0</span><span>),
</span><span>    args : command_split,
</span><span>  };
</span><span>
</span><span>  command
</span><span>}
</span></code></pre>
<p>Before getting to the next step of evaluating the parsed command, I want to take a moment to learn how to set up tests that will run with the builds. See you next time. </p>

</div>

<div class="blog-nav-footer">
    <hr/>
    
    
</div>

  </div>

</body>

</html>