<!DOCTYPE html>
<html lang="en">

<head>
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
Using a database + gRPC with Rust &middot; T.J. Telan
</title>

  <!-- CSS -->
  <link rel="stylesheet" href="https://tjtelan.com/print.css" media="print">
  <link rel="stylesheet" href="https://tjtelan.com/tj.css">
  <!--<link rel="stylesheet" href="https://tjtelan.com/newsletter.css">-->
  <link rel="stylesheet" href="https://tjtelan.com/hyde.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Sans:400,400italic,700|Abril+Fatface">
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">

  
  
  <link rel="alternate" type="application/atom+xml" title="Atom" href="https://tjtelan.com/atom.xml">
  
  
  
  <!-- Facebook open graph tags-->
  <meta property="og:type" content="website" />
  <meta property="og:url" content="https://tjtelan.com/blog/using-a-database-grpc-with-rust/" />
   
  <meta property="og:title" content="Using a database + gRPC with Rust" />
  
  
  <meta property="og:description" content="A demonstration of a Rust CLI application using GRPC and PostgreSQL" />
  
  <!-- Twitter card tags -->
  <meta name="twitter:card" content="summary" />
  <meta name="twitter:url" content="https://tjtelan.com/blog/using-a-database-grpc-with-rust/" />
   
  <meta name="twitter:title" content="Using a database + gRPC with Rust" />
  
  
  <meta name="twitter:description" content="A demonstration of a Rust CLI application using GRPC and PostgreSQL" />
  
  <meta name="twitter:creator" content="@ThatTJTelan" />
  <meta name="twitter:site" content="@ThatTJTelan" />

  
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-M280GK01DY"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-M280GK01DY');
</script>


<!-- Plausible Analytics -->
<script defer data-domain="tjtelan.com" src="https://analytics.analogorithm.net/js/script.js"></script>

</head>

<body class=" ">
  
  <div  id="sidebar" class="sidebar">
    <div class="container sidebar-sticky">
      <div class="sidebar-about">
        
        <a href="https://tjtelan.com">
          <h1>T.J. Telan</h1>
        </a>
        
        <p class="lede">Practical DevOps &amp; Developer Experience</p>
        
        
      </div>

      <ul class="sidebar-nav">
        
          
            
            <li class="sidebar-nav-item">
              <a href="/now/">Now</a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="/about/">About</a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="https://github.com/tjtelan">Github<img src="/nav-icons/github.svg" alt="Github"></a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="https://dev.to/tjtelan">Dev.to<img src="/nav-icons/dev-dot-to.svg" alt="Dev.to"></a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="https://medium.com/@tjtelan">Medium<img src="/nav-icons/medium.svg" alt="Medium"></a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="https://twitter.com/ThatTJTelan">Twitter<img src="/nav-icons/twitter.svg" alt="Twitter"></a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="https://www.twitch.tv/tjtelan">Twitch<img src="/nav-icons/twitch.svg" alt="Twitch"></a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="https://www.youtube.com/channel/UCiwV2NFMF26A5nfakQbuZ-g">YouTube<img src="/nav-icons/youtube.svg" alt="YouTube"></a>
            </li>
            
          
            
            <li class="sidebar-nav-item">
              <a href="/atom.xml">RSS<img src="/nav-icons/rss.svg" alt="RSS"></a>
            </li>
            
          
        
      </ul>
    </div>
  </div>
  

  <div class="content container">
    
<div class="post">
    <h1 class="post-title">Using a database + gRPC with Rust</h1>
    
    <span class="post-meta">
        17 min read
        &nbsp;&bull;&nbsp;
        2019-04-25
        
          &nbsp;&bull;
          
          &nbsp;
          <a  href="https://tjtelan.com/categories/how-to/">
              how-to
            </a>
          
        
        
          &nbsp;&bull;
          
          &nbsp;
          <a  href="https://tjtelan.com/tags/rust/">
              #rust
            </a>
          
          &nbsp;
          <a  href="https://tjtelan.com/tags/database/">
              #database
            </a>
          
          &nbsp;
          <a  href="https://tjtelan.com/tags/diesel-rs/">
              #diesel-rs
            </a>
          
          &nbsp;
          <a  href="https://tjtelan.com/tags/grpc/">
              #grpc
            </a>
          
          &nbsp;
          <a  href="https://tjtelan.com/tags/grpc-rs/">
              #grpc-rs
            </a>
          
          &nbsp;
          <a  href="https://tjtelan.com/tags/tower-rs/">
              #tower-rs
            </a>
          
          &nbsp;
          <a  href="https://tjtelan.com/tags/cli/">
              #cli
            </a>
          
          &nbsp;
          <a  href="https://tjtelan.com/tags/clap-rs/">
              #clap-rs
            </a>
          
        
      </span>

    <blockquote>
<p>Update: 8/19/2020</p>
<p>If you're here for <a rel="noopener nofollow" target="_blank" href="https://grpc.io/">gRPC</a> or CLI, this post uses old crates and you should read <a href="https://tjtelan.com/blog/lets-build-a-single-binary-grpc-server-client-with-rust-in-2020/">this post</a> instead.</p>
<p>I have a new post using more up-to-date Rust with <code>async</code>/<code>await</code>. The new guide uses <a rel="noopener nofollow" target="_blank" href="https://github.com/hyperium/tonic">Tonic</a> for gRPC and <a rel="noopener nofollow" target="_blank" href="https://github.com/TeXitoi/structopt">StructOpt</a> for CLI. (But no database stuff)</p>
<p>This post is still good if you want to see how to use <a rel="noopener nofollow" target="_blank" href="http://diesel.rs/">Diesel</a> with <a rel="noopener nofollow" target="_blank" href="https://www.postgresql.org/">PostgreSQL</a>. But if you're here for gRPC, you should check out the <a href="https://tjtelan.com/blog/lets-build-a-single-binary-grpc-server-client-with-rust-in-2020/">new post</a>.</p>
<p>Thanks for listening! Now back to your regularly scheduled program...</p>
</blockquote>
<hr />
<p>This is a summary of my experience with writing a Rust DB-backed server/client with <a rel="noopener nofollow" target="_blank" href="https://github.com/pingcap/grpc-rs">grpc-rs</a> to communicate to the backend, and <a rel="noopener nofollow" target="_blank" href="http://diesel.rs/">Diesel</a> as an ORM to be used with <a rel="noopener nofollow" target="_blank" href="https://www.postgresql.org/">PostgreSQL</a>.</p>
<h2 id="what-did-i-want-out-of-this-exercise">What did I want out of this exercise?<a class="zola-anchor" href="#what-did-i-want-out-of-this-exercise" aria-label="Anchor link for: what-did-i-want-out-of-this-exercise">ðŸ”—</a></h2>
<p>I don't consider myself an expert with Rust, also not a beginner. I've been following the Rust language development for a while. I also have been wanting to move from writing code for personal projects to writing for work projects. </p>
<p>I have the privilege to choose the tools I want at work, but I must keep in mind that I don't work by myself. I need to be able to provide practical development advice and enough technical mentorship to my teammates to keep us all productive.</p>
<p><a rel="noopener nofollow" target="_blank" href="https://medium.com/@KevinHoffman/streaming-grpc-with-rust-d978fece5ef6">Kevin Hoffmanâ€™s blog post</a> let me know that what I wanted was possible today in stable (as opposed to nightly). Kevinâ€™s post is great, but I couldnâ€™t really absorb it my first few reads, because he is a more experienced Rust developer than myself. I didn't quite understand the code in his post, and I couldnâ€™t appreciate details he skimmed over which I will point out. I hope that I can provide supplemental details.</p>
<h3 id="my-target">My target<a class="zola-anchor" href="#my-target" aria-label="Anchor link for: my-target">ðŸ”—</a></h3>
<p>I am looking to build a very basic command line interface client, and a backend service. The cli communicates to the backend via gRPC, and the backend connects to a database.</p>
<p><strong>gRPC</strong></p>
<p>Based on Kevin Hoffman's experience, and the download activity on crates.io, I also used Pingcap's library <a rel="noopener nofollow" target="_blank" href="https://github.com/pingcap/grpc-rs">grpc-rs</a>. However, while writing this post <a rel="noopener nofollow" target="_blank" href="https://github.com/tower-rs/tower-grpc">tower-rs</a> (which is a pure Rust implementation) is considered to be stable, though may not yet implement all features.</p>
<p><strong>Database</strong></p>
<p>For database, I decided to use <a rel="noopener nofollow" target="_blank" href="https://crates.io/crates/diesel">Diesel-rs</a> since there really arenâ€™t any other choices that I felt were better in a production environment. Diesel is a mature project that is very actively supported.</p>
<p><strong>Command line interface</strong></p>
<p>For the command line interface, I picked <a rel="noopener nofollow" target="_blank" href="https://crates.io/crates/clap">clap-rs</a>, because I was interested in trying out defining the command line content and structure with yaml. In the future I would probably use <a rel="noopener nofollow" target="_blank" href="https://crates.io/crates/structopt">StructOpt</a>. It happens to use clap-rs internally, but the written code is easier for me to read, and in my opinion, less code to write derives. For this reason, Iâ€™ll probably gloss over the command line implementation. It provides the minimal amount of interaction I needed to highlight what appears to be an idiomatic pattern. </p>
<p>After spending a few hours with all the tools, I wanted to jump in feet first with an example project.</p>
<h2 id="my-first-attempt-figuring-out-my-development-pattern">My first attempt figuring out my development pattern<a class="zola-anchor" href="#my-first-attempt-figuring-out-my-development-pattern" aria-label="Anchor link for: my-first-attempt-figuring-out-my-development-pattern">ðŸ”—</a></h2>
<p>I briefly considered not telling the parts of the story where I was figuring out how to get everything to compile but here it is. It ended up being a big learning experience. I won't get into super deep detail about my intentions since I ended up not going in this direction. But I will highlight what I learned.</p>
<p>I focused on individually building with Diesel and gRPC. Once I felt ready to do something productive with these crates, I started thinking about implementation by designing the protocol buffers first, and designing the database later. This ended up being a time-expensive mistake that hopefully will not need to repeated, dear Reader.</p>
<h3 id="red-flags-in-the-workflow">Red flags in the workflow<a class="zola-anchor" href="#red-flags-in-the-workflow" aria-label="Anchor link for: red-flags-in-the-workflow">ðŸ”—</a></h3>
<p>I am generating my proto Rust code from <code>.proto</code> using <a rel="noopener nofollow" target="_blank" href="https://github.com/pingcap/grpc-rs">grpc-rs</a> in my <a rel="noopener nofollow" target="_blank" href="https://github.com/tjtelan/rust-examples/blob/main/cli-clap-grpc-pingcap-db-diesel/workspace/protos/build.rs">build.rs</a>. It runs during <code>cargo build</code>. Based on Diesel's <a rel="noopener nofollow" target="_blank" href="http://diesel.rs/guides/getting-started/">getting started</a> guide, I expected that I would be annotating my proto Rust with the same <code>#[derive()]</code>. </p>
<p>But If I'm going to be using the generated structs w/ Diesel, then I have to break up the protobuf compilation w/ some manual step to additionally add in the correct annotations, because the next <code>cargo build</code> regenerated code and removed my manual changes. This was a red flag, but I kept moving forward anyway...</p>
<p>Diesel also expects that your struct fields are 1:1 with your table schema for to use the custom  <code>#[Derive(Queryable)]</code> for querying the DB. If you haven't looked at <code>grpc-rs</code> generated grpc code, you'll see extra internally used struct fields: <code>unknown_fields</code> and <code>cached_size</code>. These are part of <code>grpc-rs</code>â€™s implementation of message serialization/deserialization. Moving forward could require representing these extra fields in the database, which has a bad smell and is wasteful of space. </p>
<p><strong>Example of grpc-rs generated Rust code w/ the special fields</strong></p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[derive(PartialEq,Clone,Default)]
</span><span style="color:#569cd6;">pub struct </span><span>OrderForm {
</span><span>    </span><span style="color:#608b4e;">// message fields
</span><span>    </span><span style="color:#569cd6;">pub </span><span>quantity: </span><span style="color:#569cd6;">i32</span><span>,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>product: OilProductType,
</span><span>    </span><span style="color:#608b4e;">// special fields
</span><span>    </span><span style="color:#569cd6;">pub </span><span>unknown_fields: ::protobuf::UnknownFields,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>cached_size: ::protobuf::CachedSize,
</span><span>}
</span></code></pre>
<blockquote>
<p>Choosing to work directly with this generated struct means manually modifying the list of derive() and working around the special fields <code>unknown_fields</code> and <code>cached_size</code> so Diesel could still be used inserts and queries. Possibly requiring adding columns in the table schema. This is a more tight coupling than I want between my protobuf library and the data in the database.</p>
</blockquote>
<h3 id="what-i-should-have-done">What I should have done<a class="zola-anchor" href="#what-i-should-have-done" aria-label="Anchor link for: what-i-should-have-done">ðŸ”—</a></h3>
<p>I only realized this after writing the client/server using the raw proto structs. I then moved onto designing the db schema and migrations. I got stuck trying to flow the grpc client calls to db inserts.</p>
<p>I concluded that I would need to create new structs that only Diesel would use since their support heavily relies on Derive code. It all felt like an impedance mismatch, and I was having to redo the same work over again without a clear path for where I was going.</p>
<p>This was a failure. If I could work backwards from the database inserts to the protos, then this might work out better for my understanding.</p>
<h2 id="my-second-approach">My second approach<a class="zola-anchor" href="#my-second-approach" aria-label="Anchor link for: my-second-approach">ðŸ”—</a></h2>
<h3 id="before-implementation">Before implementation<a class="zola-anchor" href="#before-implementation" aria-label="Anchor link for: before-implementation">ðŸ”—</a></h3>
<p>I'm still learning how to write idiomatic Rust. When I got my protos compiling into generated Rust code, and assumed I needed to use it directly because it is native code, despite my unfamiliarity with all of the code generated by Pingcapâ€™s gRPC library.</p>
<blockquote>
<p>Iâ€™m relying heavily on the use of the Into trait to create a little anti-corruption layer so that the business logic on both my client and my server are not operating directly on the protobuf-generated structs. <em>-- Kevin Hoffman</em></p>
</blockquote>
<p>After a not-skimmed reading of <a rel="noopener nofollow" target="_blank" href="https://medium.com/@KevinHoffman/streaming-grpc-with-rust-d978fece5ef6">Kevin's Hoffman's post</a>, I noticed he described using this same approach in a hand-wavey manner. I wasn't ready to appreciate the warning without some example code or a diagram.</p>
<h4 id="use-separate-structs-for-business-logic">Use separate structs for business logic<a class="zola-anchor" href="#use-separate-structs-for-business-logic" aria-label="Anchor link for: use-separate-structs-for-business-logic">ðŸ”—</a></h4>
<p>I hadnâ€™t immediately considered that I might want to write my own structs instead of using the protobuf-generated structs since my mindset was that the generated code would be ergonomic enough to use code.</p>
<p>However, the strategy of using separate structs offers very easy to use conversions because of the <code>From</code> and <code>Into</code> traits. This would be easier for the maintainability and readability of my code because I can contain that conversion logic in away from my business logic.</p>
<p>I could convert them back and forth between the protobuf-generated forms and the diesel supported forms with <code>.into()</code>. How is this achieved?</p>
<p>More on this during implementation...</p>
<h5 id="what-is-using-this-pattern-like-in-the-code">What is using this pattern like in the code?<a class="zola-anchor" href="#what-is-using-this-pattern-like-in-the-code" aria-label="Anchor link for: what-is-using-this-pattern-like-in-the-code">ðŸ”—</a></h5>
<p>An example interaction would look like this</p>
<p>Inserts into the database - Client side:</p>
<ol>
<li>User input </li>
<li>Create Diesel struct + any data manipulation </li>
<li>Convert Diesel struct into Proto struct </li>
<li>Send Proto struct in gRPC call</li>
</ol>
<p>Inserts into the database - Server side:</p>
<ol>
<li>Receive Proto struct</li>
<li>Convert Proto struct into Diesel struct + Any data manipulation</li>
<li>Insert into DB</li>
</ol>
<h4 id="the-last-complicated-detail-rust-custom-types-mapping-to-postgres-enums">The Last complicated detail : Rust custom types mapping to Postgres Enums<a class="zola-anchor" href="#the-last-complicated-detail-rust-custom-types-mapping-to-postgres-enums" aria-label="Anchor link for: the-last-complicated-detail-rust-custom-types-mapping-to-postgres-enums">ðŸ”—</a></h4>
<p>I want to use Rust enums and Postgres enums to carry my usage of types all the way to DB insert/query. The diesel schema generator doesn't handle custom postgres enums well, but we can manage the conversion by hand by using a few Diesel Derives: <code>SqlType</code>, <code>FromSql</code>, and <code>ToSql</code> . I might cover using custom postgres types with Diesel in another post. But for now, I am going to hand-wave this detail.</p>
<p>The <a rel="noopener nofollow" target="_blank" href="https://github.com/diesel-rs/diesel/blob/v1.3.1/diesel_tests/tests/custom_types.rs">Diesel-rs custom types tests</a> were very useful helping me figure it out.</p>
<h4 id="organizing-code-into-cargo-workspaces">Organizing code into cargo workspaces<a class="zola-anchor" href="#organizing-code-into-cargo-workspaces" aria-label="Anchor link for: organizing-code-into-cargo-workspaces">ðŸ”—</a></h4>
<p>With some experience under my belt and a better understanding of where relative domains in the code should be separated by crate, I wanted to organize before writing new code. The first thing I did was separate the codebase into <a rel="noopener nofollow" target="_blank" href="https://doc.rust-lang.org/book/ch14-03-cargo-workspaces.html#creating-a-workspace">workspaces</a>.</p>
<p>Separating into different crates would let me organize the struct conversion code from complicating the readability of the business logic code. This will make it easier to reuse patterns between the client and server side through importing the crates.</p>
<h3 id="implementation">Implementation<a class="zola-anchor" href="#implementation" aria-label="Anchor link for: implementation">ðŸ”—</a></h3>
<h4 id="write-database-schema">Write database schema<a class="zola-anchor" href="#write-database-schema" aria-label="Anchor link for: write-database-schema">ðŸ”—</a></h4>
<p>Because I need some kind of story to write code against, I decided to write an oil ordering system (because proto-diesel can be described as oilâ€¦ har harâ€¦)</p>
<p>My postgres type <code>oil_product</code> has a <a rel="noopener nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Oil_refinery#/media/File:Usesofpetroleum.png">pie chart</a> of oil derived products that I got from the <a rel="noopener nofollow" target="_blank" href="https://en.wikipedia.org/wiki/Oil_refinery#Major_products">wiki page of Oil Refinery</a></p>
<p>That helped me with my first thing: I need my database schema - <a rel="noopener nofollow" target="_blank" href="https://github.com/tjtelan/rust-examples/blob/main/cli-clap-grpc-pingcap-db-diesel/workspace/models/schema.rs">schema.rs</a></p>
<p>Then I could write my migrations:</p>
<ul>
<li><a rel="noopener nofollow" target="_blank" href="https://github.com/tjtelan/rust-examples/blob/main/cli-clap-grpc-pingcap-db-diesel/workspace/migrations/2019-03-18-213310_create_orders/up.sql">up.sql</a></li>
<li><a rel="noopener nofollow" target="_blank" href="https://github.com/tjtelan/rust-examples/blob/main/cli-clap-grpc-pingcap-db-diesel/workspace/migrations/2019-03-18-213310_create_orders/down.sql">down.sql</a></li>
</ul>
<h4 id="get-inserts-into-db-working">Get inserts into DB working<a class="zola-anchor" href="#get-inserts-into-db-working" aria-label="Anchor link for: get-inserts-into-db-working">ðŸ”—</a></h4>
<p>Second is getting inserts into the db working on the backend - <a rel="noopener nofollow" target="_blank" href="https://github.com/tjtelan/rust-examples/commit/0e40e27529170b22f5419559ce8659f7a1a154f3#diff-149a61a7aa6246849298372d0b2f196e">Link to specific commit</a></p>
<p><strong>backend.rs</strong></p>
<p>This is a simple call from the backend to an internal function that performs the DB insert. After opening a connection, I test create a hardcoded order.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>[</span><span style="color:#569cd6;">...</span><span>]
</span><span style="color:#569cd6;">let</span><span> conn = client::establish_connection();
</span><span style="color:#569cd6;">let</span><span> new_order = client::create_order(</span><span style="color:#569cd6;">&amp;</span><span>conn, </span><span style="color:#b5cea8;">1</span><span>, schema::OilProductEnum::</span><span style="color:#b4cea8;">DIESEL</span><span>);
</span><span>[</span><span style="color:#569cd6;">...</span><span>]
</span></code></pre>
<p><strong>create_order</strong></p>
<p>This insert only works once because the id is set to <code>1</code>. But the result is in insert of an order into the database, and returning the inserted <code>Order</code> from the function. </p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">pub fn </span><span>create_order(conn : </span><span style="color:#569cd6;">&amp;</span><span>PgConnection, quantity : </span><span style="color:#569cd6;">i32</span><span>, product_type : OilProductEnum) -&gt; Order {
</span><span>    </span><span style="color:#569cd6;">let</span><span> new_order = vec![
</span><span>        Order {
</span><span>            id : </span><span style="color:#b5cea8;">1</span><span>,
</span><span>            quantity : quantity,
</span><span>            product_type : product_type,
</span><span>        },
</span><span>    ];
</span><span>
</span><span>    diesel::insert_into(orders::table)
</span><span>        .values(</span><span style="color:#569cd6;">&amp;</span><span>new_order)
</span><span>        .get_result(conn)
</span><span>        .expect(</span><span style="color:#d69d85;">&quot;Error saving new order&quot;</span><span>)
</span><span>}
</span></code></pre>
<h5 id="creating-user-input-structs-for-business-logic">Creating user input structs for business logic<a class="zola-anchor" href="#creating-user-input-structs-for-business-logic" aria-label="Anchor link for: creating-user-input-structs-for-business-logic">ðŸ”—</a></h5>
<p>I created some structs solely for taking user input. It will converted to a proto form that will be used for gRPC calls</p>
<p>These structs didn't include dynamic info like ids or timestamps, since those are generated right before insert on the server side.</p>
<p>Separate proto messages needed to be defined specifically for taking user input from the client-side.</p>
<p><strong>One of the business logic structs</strong></p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">pub struct </span><span>OrderForm {
</span><span>    </span><span style="color:#569cd6;">pub </span><span>quantity : </span><span style="color:#569cd6;">i32</span><span>,
</span><span>    </span><span style="color:#569cd6;">pub </span><span>product_type : OilProductEnum,
</span><span>}
</span></code></pre>
<p><strong>The corresponding proto message definition</strong></p>
<pre data-lang="protobuf" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-protobuf "><code class="language-protobuf" data-lang="protobuf"><span>message OrderForm {
</span><span>    int32 quantity = 2;
</span><span>    OilProductType product = 3;
</span><span>}
</span></code></pre>
<h5 id="converting-business-logic-struct-to-from-proto-generated-struct">Converting business logic struct to/from proto-generated struct<a class="zola-anchor" href="#converting-business-logic-struct-to-from-proto-generated-struct" aria-label="Anchor link for: converting-business-logic-struct-to-from-proto-generated-struct">ðŸ”—</a></h5>
<p>I implemented the <code>From</code> trait to convert my custom type to protobuf types for the grpc client calls (and vice-versa). The <a rel="noopener nofollow" target="_blank" href="https://doc.rust-lang.org/std/convert/trait.From.html">From</a> trait gives us the <a rel="noopener nofollow" target="_blank" href="https://doc.rust-lang.org/std/convert/trait.Into.html">Into</a> implementation for free.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// Convert from the protos to our type
</span><span style="color:#569cd6;">impl </span><span>From&lt;refinery::OrderForm&gt; </span><span style="color:#569cd6;">for </span><span>OrderForm {
</span><span>    </span><span style="color:#569cd6;">fn </span><span>from(proto_form : refinery::OrderForm) -&gt; </span><span style="color:#569cd6;">Self </span><span>{
</span><span>        OrderForm {
</span><span>            quantity : proto_form.get_quantity(),
</span><span>            product_type : OilProductEnum::from(proto_form.get_product()),
</span><span>        }
</span><span>    }
</span><span>}
</span><span>
</span><span style="color:#608b4e;">// Convert from our type to the proto
</span><span style="color:#569cd6;">impl </span><span>From&lt;OrderForm&gt; </span><span style="color:#569cd6;">for </span><span>refinery::OrderForm {
</span><span>    </span><span style="color:#569cd6;">fn </span><span>from(rust_form : OrderForm) -&gt; </span><span style="color:#569cd6;">Self </span><span>{
</span><span>        </span><span style="color:#569cd6;">let mut</span><span> order = refinery::OrderForm::new();
</span><span>
</span><span>        order.set_quantity(rust_form.quantity);
</span><span>        order.set_product(refinery::OilProductType::from(rust_form.product_type));
</span><span>        order
</span><span>    }
</span><span>}
</span></code></pre>
<p>Snippet from <a rel="noopener nofollow" target="_blank" href="https://github.com/tjtelan/rust-examples/blob/main/cli-clap-grpc-pingcap-db-diesel/workspace/models/convert.rs">convert.rs</a>:</p>
<h4 id="take-user-input-before-making-grpc-call">Take user input before making gRPC call<a class="zola-anchor" href="#take-user-input-before-making-grpc-call" aria-label="Anchor link for: take-user-input-before-making-grpc-call">ðŸ”—</a></h4>
<p>We want to take user input from a client, make a grpc backend call, then insert into the db from the backend.</p>
<p>We already have taken care of converting to and from proto forms, so this is focused on control flow now.</p>
<h5 id="move-inserts-into-grpc-server-endpoint">Move inserts into gRPC server endpoint<a class="zola-anchor" href="#move-inserts-into-grpc-server-endpoint" aria-label="Anchor link for: move-inserts-into-grpc-server-endpoint">ðŸ”—</a></h5>
<p>Insert will occur after calling into the grpc server endpoint from the client-side.</p>
<p>On the client-side, I created a protobuf-generated struct with default values, for demonstrating the gRPC call to the backend works. I can easily take user input afterwards.</p>
<h5 id="receive-proto-struct-and-convert-into-db-insertable-struct">Receive proto struct and convert into DB insertable struct<a class="zola-anchor" href="#receive-proto-struct-and-convert-into-db-insertable-struct" aria-label="Anchor link for: receive-proto-struct-and-convert-into-db-insertable-struct">ðŸ”—</a></h5>
<p>Lastly, I worked out taking in user input, and using it to instantiate one of my custom types. During the grpc backend call, I call .into() on my type, which will convert to the protobuf form. On the backend, I take in the request, and call <code>.into()</code> to convert back into my type so I can marshal into a diesel insert call.</p>
<p><strong>Server-side</strong></p>
<p>I'm converting the proto-form struct <code>req</code> into the business logic form <code>OrderForm</code> by calling <code>.into()</code>. Since the <code>create_order()</code> impl takes in <code>OrderForm</code>, there is no need to annotate the type with <code>.into()</code> and weâ€™re able to stay focused.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span>#[derive(Clone)]
</span><span style="color:#569cd6;">struct </span><span>RefineryService;
</span><span>
</span><span style="color:#569cd6;">impl </span><span>Refinery </span><span style="color:#569cd6;">for </span><span>RefineryService {
</span><span>    </span><span style="color:#608b4e;">// The client-side converts to refinery::OrderForm while calling this endpoint.
</span><span>    </span><span style="color:#608b4e;">// But we convert the proto type back to our custom type right before adding to the database
</span><span>    </span><span style="color:#569cd6;">fn </span><span>order(</span><span style="color:#569cd6;">&amp;mut </span><span>self, ctx: RpcContext, req: refinery::OrderForm, sink: UnarySink&lt;refinery::OrderStatus&gt;) {
</span><span>
</span><span>    </span><span style="color:#608b4e;">// Creating the return object
</span><span>        </span><span style="color:#569cd6;">let</span><span> order_status = client::order_received_success();
</span><span>
</span><span>        </span><span style="color:#569cd6;">let</span><span> f = sink
</span><span>            .success(order_status.clone())
</span><span>            .map(</span><span style="color:#569cd6;">move |_| </span><span>println!(</span><span style="color:#d69d85;">&quot;Responded with status </span><span style="color:#e3bbab;">{{ </span><span style="color:#b4cea8;">{:?} </span><span style="color:#e3bbab;">}}</span><span style="color:#d69d85;">&quot;</span><span>, order_status))
</span><span>            .map_err(</span><span style="color:#569cd6;">move |</span><span>err</span><span style="color:#569cd6;">| </span><span>eprintln!(</span><span style="color:#d69d85;">&quot;Failed to reply: </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span>, err));
</span><span>
</span><span>        </span><span style="color:#569cd6;">let</span><span> conn = client::establish_connection();
</span><span>        </span><span style="color:#608b4e;">// Convert the received proto request into our native type
</span><span>        </span><span style="color:#569cd6;">let</span><span> _new_order = client::create_order(</span><span style="color:#569cd6;">&amp;</span><span>conn, req.into());
</span><span>
</span><span>        ctx.spawn(f)
</span><span>    }
</span><span>}
</span></code></pre>
<p><strong>Function for creating order</strong></p>
<p>We take the business logic form <code>order_form</code> and use it to create the insertable struct <code>new_order</code> with all of the column values for Diesel to execute.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">pub fn </span><span>create_order(conn : </span><span style="color:#569cd6;">&amp;</span><span>PgConnection, order_form : OrderForm) -&gt; Order {
</span><span>    </span><span style="color:#569cd6;">let</span><span> timestamp = NaiveDateTime::from_timestamp(Utc::now().timestamp(),</span><span style="color:#b5cea8;">0</span><span>);
</span><span>
</span><span>    </span><span style="color:#569cd6;">let</span><span> new_order = vec![
</span><span>        NewOrder {
</span><span>            quantity : order_form.quantity,
</span><span>            product_type : order_form.product_type,
</span><span>            received_time : timestamp,
</span><span>        },
</span><span>    ];
</span><span>
</span><span>    diesel::insert_into(orders::table)
</span><span>        .values(</span><span style="color:#569cd6;">&amp;</span><span>new_order)
</span><span>        .get_result(conn)
</span><span>        .expect(</span><span style="color:#d69d85;">&quot;Error saving new order&quot;</span><span>)
</span><span>}
</span></code></pre>
<h5 id="do-it-again-in-reverse-for-queries">Do it again, in reverse, for queries<a class="zola-anchor" href="#do-it-again-in-reverse-for-queries" aria-label="Anchor link for: do-it-again-in-reverse-for-queries">ðŸ”—</a></h5>
<p>Last task to cover is repeating all of this work, but for making queries.</p>
<p>This ended up being slightly off pattern from implementing <code>From</code> traits, because I am returning a list of Orders, and the From trait apparently is not easily implemented for a Vec to the protobuf Rust equivilent. If I were planning on shipping this code somewhere other than for demonstration, I probably would spend more time implementing <code>From</code>. I ended up getting lazy, and wrapped the manual conversion in a function that loops and uses my already implemented From traits on the <code>Order</code> type. </p>
<p><strong>user input side</strong></p>
<p>This client subcommand from the cli requests all of the orders from the database, then prints out the protobuf form as a demonstration. The next step would be converting the protobuf list into a Vec of some non-protobuf generated type.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">if let </span><span>Some(_matches) = matches.subcommand_matches(</span><span style="color:#d69d85;">&quot;summary&quot;</span><span>) {
</span><span>    </span><span style="color:#569cd6;">let</span><span> empty_payload = protos::empty::Empty::new();
</span><span>
</span><span>    </span><span style="color:#608b4e;">// Send the gRPC message
</span><span>    </span><span style="color:#569cd6;">let</span><span> orders = client.get_all_records(</span><span style="color:#569cd6;">&amp;</span><span>empty_payload).expect(</span><span style="color:#d69d85;">&quot;RPC Failed!&quot;</span><span>);
</span><span>
</span><span>    </span><span style="color:#608b4e;">// Print all records from database
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Order status: </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span>, orders);
</span><span>}
</span></code></pre>
<p><strong>server endpoint</strong></p>
<p>The server takes in an empty proto type, so we donâ€™t have to do any type conversions. We then call a function <code>client::get_all_orders()</code> that calls Diesel to return all the data in a table. Then we make another function call <code>client::db_query_to_proto()</code> to convert our native data into a gRPC sendable form.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#569cd6;">fn </span><span>get_all_records(</span><span style="color:#569cd6;">&amp;mut </span><span>self, ctx: RpcContext, _req: protos::empty::Empty, sink: UnarySink&lt;refinery::OrderRecordList&gt;){
</span><span>    println!(</span><span style="color:#d69d85;">&quot;Received request for all of the order records&quot;</span><span>);
</span><span>    </span><span style="color:#569cd6;">let</span><span> conn = client::establish_connection();
</span><span>
</span><span>    </span><span style="color:#608b4e;">// Call out to db
</span><span>    </span><span style="color:#569cd6;">let</span><span> query_results = client::get_all_orders(</span><span style="color:#569cd6;">&amp;</span><span>conn);
</span><span>
</span><span>    </span><span style="color:#608b4e;">// This conversion pattern is different than the plain `From` traits, because we
</span><span>    </span><span style="color:#608b4e;">// have to handle the outer vector in a special way, but I want to be lazy
</span><span>    </span><span style="color:#569cd6;">let</span><span> parsed_query_proto = client::db_query_to_proto(query_results);
</span><span>    </span><span style="color:#608b4e;">//println!(&quot;Got results from the database: {:?}&quot;, query_results);
</span><span>
</span><span>    </span><span style="color:#569cd6;">let</span><span> f = sink
</span><span>        .success(parsed_query_proto.clone())
</span><span>        .map(</span><span style="color:#569cd6;">move |_| </span><span>println!(</span><span style="color:#d69d85;">&quot;Responded with list of records </span><span style="color:#e3bbab;">{{ </span><span style="color:#b4cea8;">{:?} </span><span style="color:#e3bbab;">}}</span><span style="color:#d69d85;">&quot;</span><span>, parsed_query_proto))
</span><span>        .map_err(</span><span style="color:#569cd6;">move |</span><span>err</span><span style="color:#569cd6;">| </span><span>eprintln!(</span><span style="color:#d69d85;">&quot;Failed to reply: </span><span style="color:#b4cea8;">{:?}</span><span style="color:#d69d85;">&quot;</span><span>, err));
</span><span>
</span><span>    ctx.spawn(f)
</span><span>}
</span></code></pre>
<p><strong>database query</strong></p>
<p>This function queries for everything in the orders table. There's nothing interesting here because Diesel handles everything. I just needed to annotate the type of vector that Diesel was going to return.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// get_all_orders is used by the backend
</span><span style="color:#569cd6;">pub fn </span><span>get_all_orders(conn : </span><span style="color:#569cd6;">&amp;</span><span>PgConnection) -&gt; Vec&lt;Order&gt; {
</span><span>    </span><span style="color:#569cd6;">let</span><span> query : Vec&lt;Order&gt; = orders::table.select(orders::all_columns)
</span><span>    .order_by(orders::id)
</span><span>    .load(conn)
</span><span>    .expect(</span><span style="color:#d69d85;">&quot;Error getting all order records&quot;</span><span>);
</span><span>    query
</span><span>}
</span></code></pre>
<p><strong>query to protobuf list</strong></p>
<p>You don't need to use all of the Rust features all up front or not use Rust at all. We can all hopefully appreciate that this can still be understood.</p>
<p>I briefly tried to implement <code>From</code> for <code>Vec&lt;Order&gt;</code>, but it became evident that it was going to take a little more effort than I was willing to spend at this moment. I'm first to admit that this is a bit of a hack, but that's fine for demonstration purposes. </p>
<p>Protobuf's <code>repeated</code> keyword in the Rust code has its own type like <code>Vec&lt;T&gt;</code> called <code>RepeatedField</code> and we are simply looping through and creating a <code>Vec&lt;refinery::OrderRecord&gt;</code> so we could use the conversion impl <code>from_vec</code>. The rest is for building the return data.</p>
<pre data-lang="rust" style="background-color:#1e1e1e;color:#dcdcdc;" class="language-rust "><code class="language-rust" data-lang="rust"><span style="color:#608b4e;">// db_query_to_proto is used by the backend to convert a Vector of Order (from a Diesel select
</span><span style="color:#608b4e;">// query) into the proto native OrderRecordList. Implementing `From` for a Vector would have taken
</span><span style="color:#608b4e;">// longer, and used a wrapper type. That very well may be the more maintainable approach, but this
</span><span style="color:#608b4e;">// was quickerâ€¦
</span><span>
</span><span style="color:#569cd6;">pub fn </span><span>db_query_to_proto(rust_record : Vec&lt;Order&gt;) -&gt; refinery::OrderRecordList {
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> proto_vec : Vec&lt;refinery::OrderRecord&gt; = Vec::new();
</span><span>
</span><span>    </span><span style="color:#608b4e;">// Let&#39;s take advantage of the `From` trait
</span><span>    </span><span style="color:#569cd6;">for</span><span> r </span><span style="color:#569cd6;">in</span><span> rust_record {
</span><span>        proto_vec.push(refinery::OrderRecord::from(r));
</span><span>    }
</span><span>
</span><span>    </span><span style="color:#569cd6;">let</span><span> proto_order = protobuf::RepeatedField::from_vec(proto_vec);
</span><span>
</span><span>    </span><span style="color:#569cd6;">let mut</span><span> proto_final = refinery::OrderRecordList::new();
</span><span>    proto_final.set_order(proto_order);
</span><span>    proto_final
</span><span>}
</span></code></pre>
<h2 id="in-conclusion">In conclusion<a class="zola-anchor" href="#in-conclusion" aria-label="Anchor link for: in-conclusion">ðŸ”—</a></h2>
<p>Rust library support for gRPC is here. ORM support with Diesel-rs has been here for a while. But if you want to use gRPC and Diesel in the same project, maybe you can learn from my experience and be productive.</p>
<p>Do not primarily use the protobuf generated Rust types throughout your codebase. Especially if you plan on using Diesel-rs to deal with database inserts/queries, because structs need to be 1:1 with your table schema for the smoothest experience using Diesel-rs.</p>
<p>Implement the <code>From</code>/<code>Into</code> traits to more effectively convert between business logic structs and your protobuf generated Rust structs.</p>
<p>Convert to the proto Rust types only to send/return data over gRPC calls and then immediately convert back to your business logic type on the receiving end.</p>
<p>You don't need to write perfect Rust code in one go.</p>
<hr />
<p>The code used throughout this post is located <a rel="noopener nofollow" target="_blank" href="https://github.com/tjtelan/rust-examples/tree/main/cli-clap-grpc-pingcap-db-diesel">here</a>.</p>

</div>

<div class="blog-nav-footer">
    <hr/>
    
    
</div>

  </div>

</body>

</html>